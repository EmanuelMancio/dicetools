"""
Receives a Gaussian's ".log" of a scan generated by plot_eff_tors, the generated .dfr,
.txt and atoms defining the dihedral to fit the classical curve to the one from the .log.

Author: Henrique Musseli Cezar
Date: MAY/2019
"""

import argparse
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import openbabel
import pybel
from numpy import cos
from scipy.optimize import curve_fit
from plot_en_angle_gaussian_scan import parse_en_log_gaussian
from plot_eff_tors import *

def species_coord_to_openbabel(species, coord):
  mol = openbabel.OBMol()
  
  # add atoms to mol
  for i, atomSp in species.items():
    a = mol.NewAtom()
    a.SetAtomicNum(int(atomSp))
    a.SetVector(*coord[i])

  # perceive bond information
  mol.ConnectTheDots()
  mol.PerceiveBondOrders()

  return mol

def equal_parameters(dihedrals, mol):
  infoAtom = []
  for dih in dihedrals:
    a1 = mol.GetAtomById(dih[0]-1)
    a4 = mol.GetAtomById(dih[3]-1)
    infoAtom.append([a1.GetAtomicNum(), a1.GetValence(), a1.GetHyb(), a4.GetAtomicNum(), a4.GetValence(), a4.GetHyb()])

  equals = []
  for i, pair1 in enumerate(infoAtom):
    # compare to all others
    for j, pair2 in enumerate(infoAtom):
      if j <= i: continue

      pair3 = pair2[3:]+pair2[:3]

      if (pair1 == pair2) or (pair1 == pair3):
        equals.append([i,j])

  # print(infoAtom)    
  # print(equals)

  return equals

def torsen_opls(phi, V1, V2, V3, f1, f2, f3):
  return 0.5 * (V1*(1.+cos(phi+f1)) + V2*(1.-cos(2.*phi+f2)) + V3*(1.+cos(3.*phi+f3)))

def torsen_amber(phi, V1, V2, V3, f1, f2, f3):
  return 0.5 * (V1*(1.+cos(phi-f1)) + V2*(1.+cos(2.*phi-f2)) + V3*(1.+cos(3.*phi-f3)))

# thanks to https://stackoverflow.com/a/34226673
def fit_func(phi, *args):
  nfunc = int(len(args)/6)
  sumf = 0.
  for i in range(nfunc):
    sumf += torsen_opls(phi,*args[6*i:6*(i+1)])
  return sumf

def fit_func2(phi, *args):
  # first half are fs

  # second half are vs
  
  nfunc = int(len(args)/6)
  sumf = 0.
  for i in range(nfunc):
    sumf += torsen_opls(phi,*vs[6*i:6*(i+1)],*fs)
  return sumf


def shift_angle_rad(tetha):
  if tetha < 0.0:
    return tetha
  elif tetha >= np.pi:
    return tetha-(2.*np.pi)
  else:
    return tetha

if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Receives a Gaussians ".log" of a scan generated by plot_eff_tors, the generated .dfr, .txt and atoms defining the dihedral to fit the classical curve to the one from the .log.')
  parser.add_argument("logfile", help="Gaussian's .log file")
  parser.add_argument("dfrfile", help=".dfr containing current parameters")
  parser.add_argument("txtfile", help=".txt containing the geometry and nonbonded parameters")
  parser.add_argument("a1", type=int, help="first atom defining the reference dihedral")
  parser.add_argument("a2", type=int, help="second atom defining the reference dihedral")
  parser.add_argument("a3", type=int, help="third atom defining the reference dihedral")
  parser.add_argument("a4", type=int, help="fourth atom defining the reference dihedral")
  parser.add_argument("--amber", help="use AMBER rule to 1-4 interactions and torsional energy", action="store_true")
  args = parser.parse_args()

  # parse data from the log file
  died, enqm = parse_en_log_gaussian(args.logfile)
  died = [shift_angle_rad(x*np.pi/180.) for x in died]

  # parse dfr to get the dihedrals involved in the rotation
  dihedralsDict, connInfo, fragInfo, fconnInfo = parse_dfr(args.dfrfile, args.a2, args.a3)

  # parse txt to get geometry
  _, natoms, atomSp, atomsCoord, _ = parse_txt(args.txtfile)
  mol = species_coord_to_openbabel(atomSp, atomsCoord)

  # get dihedrals which should have the same parameters
  equals = equal_parameters([dihedralsDict[x][:4] for x in dihedralsDict], mol)

  # get initial dihedral angles for each torsional involved in the rotation
  dihAngles = []
  for tors in dihedralsDict:
    acoords = [atomsCoord[x] for x in dihedralsDict[tors][:4]]
    dihAngles.append(get_phi(*acoords))

  # get the classical curve with current parameters
  diedClass, _, nben, _ =  get_potential_curve(args.txtfile, args.dfrfile, args.a1, args.a2, args.a3, args.a4, len(died), "", False, args.amber, False, False)
  # convert the angles and sort
  diedClass = [shift_angle_rad(x) for x in diedClass]
  diedClass, nben = (list(t) for t in zip(*sorted(zip(diedClass, nben))))

  # shift the energies to the same reference
  # min_mq = min(enqm)
  # enqm = [x-min_mq for x in enqm]
  # min_class = nben[np.argmin(enqm)] # set as zero the same angle used before for QM
  # nben = [x-min_class for x in nben]

  # fit!
  v0s = []
  f0s = []
  for i, dih in enumerate(dihedralsDict):
    v0s += dihedralsDict[dih][4:7]
    f0s += [dihAngles[i]+dihedralsDict[dih][7], 2.*dihAngles[i]+dihedralsDict[dih][8], 3.*dihAngles[i]+dihedralsDict[dih][9]]

  print(v0s)
  print(f0s)

  enqm = np.asarray(enqm)
  nben = np.asarray(nben)

  enfit = enqm - nben
  min_en = min(enfit)
  enfit = [x-min_en for x in enfit]

  # how to use just a few params https://stackoverflow.com/a/12208940
  popt, pcov = curve_fit(fit_func, died, enfit, p0=params)
  print(len(popt))
  print('Fitted values:', *popt)

  fcurv = []
  for val in died:
    fcurv.append(fit_func(val,*popt))

  plt.plot(died, enfit)
  # plt.plot(diedClass, nben)
  plt.plot(died, fcurv, 'r-', label='fit')
  plt.show()