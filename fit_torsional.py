"""
Receives a Gaussian's ".log" of a scan generated by plot_eff_tors, the generated .dfr,
.txt and atoms defining the dihedral to fit the classical curve to the one from the .log.

Author: Henrique Musseli Cezar
Date: MAY/2019
"""

import argparse
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import openbabel
import pybel
from numpy import cos
from scipy.optimize import curve_fit
from plot_en_angle_gaussian_scan import parse_en_log_gaussian
from plot_eff_tors import *

def species_coord_to_openbabel(species, coord):
  mol = openbabel.OBMol()
  
  # add atoms to mol
  for i, atomSp in species.items():
    a = mol.NewAtom()
    a.SetAtomicNum(int(atomSp))
    a.SetVector(*coord[i])

  # perceive bond information
  mol.ConnectTheDots()
  mol.PerceiveBondOrders()

  return mol


def equal_parameters(dihedrals, mol):
  infoAtom = []
  for dih in dihedrals:
    a1 = mol.GetAtomById(dih[0]-1)
    a4 = mol.GetAtomById(dih[3]-1)
    infoAtom.append([a1.GetAtomicNum(), a1.GetValence(), a1.GetHyb(), a4.GetAtomicNum(), a4.GetValence(), a4.GetHyb()])

  equals = []
  for i, pair1 in enumerate(infoAtom):
    # compare to all others
    for j, pair2 in enumerate(infoAtom):
      if j <= i: continue

      pair3 = pair2[3:]+pair2[:3]

      if (pair1 == pair2) or (pair1 == pair3):
        equals.append([i,j])

  # print(infoAtom)    
  # print(equals)

  return equals


def torsen_opls(phi, V1, V2, V3, f1, f2, f3):
  return 0.5 * (V1*(1.+cos(phi+f1)) + V2*(1.-cos(2.*phi+f2)) + V3*(1.+cos(3.*phi+f3)))


def torsen_amber(phi, V1, V2, V3, f1, f2, f3):
  return 0.5 * (V1*(1.+cos(phi-f1)) + V2*(1.+cos(2.*phi-f2)) + V3*(1.+cos(3.*phi-f3)))


# thanks to https://stackoverflow.com/a/34226673
def fit_func(phi, *args):
  # first half are vs
  vs = args[:int(len(args)/2)]
  # second half are fs
  fs = args[int(len(args)/2):]
  nfunc = int(len(args)/6)
  sumf = 0.
  for i in range(nfunc):
    sumf += torsen_opls(phi,*vs[3*i:3*(i+1)],*fs[3*i:3*(i+1)])
  return sumf


def shift_angle_rad(tetha):
  if tetha < 0.0:
    return tetha
  elif tetha >= np.pi:
    return tetha-(2.*np.pi)
  else:
    return tetha


def write_dfr(dfrfile, dihedrals, params, amber):
  with open(dfrfile, "r") as f:
    line = f.readline()

    while "$dihedral" not in line:
      print(line,end='')
      line = f.readline()

    print(line,end='')
    line = f.readline()
    
    dnum = 1
    pdied = 0
    while "$end dihedral" not in line:
      if dnum in dihedrals:
        # write the fitted parameters
        if amber:
          print("%d %d %d %d\t\tAMBER\t%.3f\t%.3f\t%.3f\t0.0\t0.0\t0.0" % (*dihedrals[dnum][:4], *params[3*pdied:3*(pdied+1)]))
        else:
          print("%d %d %d %d\t\tOPLS\t%.3f\t%.3f\t%.3f\t0.0\t0.0\t0.0" % (*dihedrals[dnum][:4], *params[3*pdied:3*(pdied+1)]))
        pdied += 1
      else:
        print(line,end='')

      dnum += 1
      line = f.readline()

    print(line,end='')
    for line in f:
      print(line,end='')


if __name__ == '__main__':
  parser = argparse.ArgumentParser(description='Receives a Gaussians ".log" of a scan generated by plot_eff_tors, the generated .dfr, .txt and atoms defining the dihedral to fit the classical curve to the one from the .log.')
  parser.add_argument("logfile", help="Gaussian's .log file")
  parser.add_argument("dfrfile", help=".dfr containing current parameters")
  parser.add_argument("txtfile", help=".txt containing the geometry and nonbonded parameters")
  parser.add_argument("a1", type=int, help="first atom defining the reference dihedral")
  parser.add_argument("a2", type=int, help="second atom defining the reference dihedral")
  parser.add_argument("a3", type=int, help="third atom defining the reference dihedral")
  parser.add_argument("a4", type=int, help="fourth atom defining the reference dihedral")
  parser.add_argument("--amber", help="use AMBER rule to 1-4 interactions and torsional energy", action="store_true")
  parser.add_argument("--bound-values", type=float, help="upper and lower bound [-val,+val] for the fitted parameters (default = 5)", default=5.)
  args = parser.parse_args()

  # parse data from the log file
  died, enqm = parse_en_log_gaussian(args.logfile)
  died = [shift_angle_rad(x*np.pi/180.) for x in died]

  # parse dfr to get the dihedrals involved in the rotation
  dihedralsDict, connInfo, fragInfo, fconnInfo = parse_dfr(args.dfrfile, args.a2, args.a3)

  # parse txt to get geometry
  _, natoms, atomSp, atomsCoord, _ = parse_txt(args.txtfile)
  mol = species_coord_to_openbabel(atomSp, atomsCoord)

  # get dihedrals which should have the same parameters
  equals = equal_parameters([dihedralsDict[x][:4] for x in dihedralsDict], mol)

  # get reference angle
  acoords = [atomsCoord[x] for x in [args.a1, args.a2, args.a3, args.a4]]
  ref_ang = get_phi(*acoords)

  # get initial dihedral angles for each torsional involved in the rotation
  dihAngles = []
  for tors in dihedralsDict:
    acoords = [atomsCoord[x] for x in dihedralsDict[tors][:4]]
    dihAngles.append(get_phi(*acoords)-ref_ang)


  # get the classical curve with current parameters
  diedClass, _, nben, _ =  get_potential_curve(args.txtfile, args.dfrfile, args.a1, args.a2, args.a3, args.a4, len(died), "", False, args.amber, False, False)
  # convert the angles and sort
  diedClass = [shift_angle_rad(x) for x in diedClass]
  diedClass, nben = (list(t) for t in zip(*sorted(zip(diedClass, nben))))

  # prepare the data and fit
  v0s = []
  f0s = []
  for i, dih in enumerate(dihedralsDict):
    v0s += dihedralsDict[dih][4:7]
    f0s += [dihAngles[i], 2.*dihAngles[i], 3.*dihAngles[i]]

  # print([180.0*x/np.pi for x in f0s])

  # set the bounds
  lbound = len(v0s)*[-args.bound_values]
  ubound = len(v0s)*[args.bound_values]

  # shift the energies to the same reference
  min_mq = min(enqm)
  enqm = [x-min_mq for x in enqm]
  min_class = nben[np.argmin(enqm)] # set as zero the same angle used before for QM
  nben = [x-min_class for x in nben]

  enqm = np.asarray(enqm)
  nben = np.asarray(nben)

  # enqm = enqm - min(enqm)
  # nben = nben - min(nben)

  enfit = enqm - nben

  # how to use just a few params https://stackoverflow.com/a/12208940
  popt, pcov = curve_fit(lambda x, *vs: fit_func(x, *vs, *f0s), died, enfit, p0=v0s, bounds=(lbound,ubound))
  # print('Fitted values:', *popt)

  popt = [round(x,3) for x in popt]

  # plot the curves to compare
  fcurv = []
  for val in died:
    fcurv.append(fit_func(val,*popt,*f0s))

  # write the adjusted dfr
  write_dfr(args.dfrfile, dihedralsDict, popt, args.amber)

  plt.plot(died, enqm, label='Gaussian total energy')
  plt.plot(died, fcurv+nben, label='Classical total energy')
  plt.plot(died, nben, label='Classical nonbonded energy')
  plt.plot(died, enfit, label='Gaussian torsional energy')
  plt.plot(died, fcurv, label='Fit')
  # plt.plot(died, enfit, color='tab:green', label='Gaussian torsional energy')
  # plt.plot(died, fcurv, color='tab:red', label='Fit')
  plt.legend()
  plt.show()